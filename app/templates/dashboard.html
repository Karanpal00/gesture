{% extends "base.html" %}

{% block title %}Dashboard - Gesture & Face Authentication API{% endblock %}

{% block content %}
<div class="row mb-4">
    <div class="col-md-12">
        <div class="card bg-dark text-white shadow-lg">
            <div class="card-body">
                <div class="row align-items-center">
                    <div class="col-md-9">
                        <h1 class="mb-0"><i class="fas fa-tachometer-alt me-3"></i>Dashboard</h1>
                        <p class="text-muted lead">Manage gestures and monitor system status</p>
                    </div>
                    <div class="col-md-3 text-end">
                        <button type="button" class="btn btn-outline-light me-2" data-bs-toggle="modal" data-bs-target="#addGestureModal">
                            <i class="fas fa-plus me-2"></i>Add Gesture
                        </button>
                        <button type="button" class="btn btn-primary" onclick="triggerTraining()">
                            <i class="fas fa-sync me-2"></i>Train Model
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="row">
    <!-- User List -->
    <div class="col-lg-4 mb-4">
        <div class="card shadow-sm h-100">
            <div class="card-header bg-primary text-white">
                <h4 class="mb-0"><i class="fas fa-users me-2"></i>Registered Users</h4>
            </div>
            <div class="card-body">
                {% if users %}
                <div class="list-group">
                    {% for user in users %}
                    <div class="list-group-item d-flex justify-content-between align-items-center">
                        <div>
                            <h5 class="mb-1">{{ user.username }}</h5>
                            <p class="mb-1 text-muted small">{{ user.email }}</p>
                            <small>Registered: {{ user.created_at.strftime('%Y-%m-%d') }}</small>
                        </div>
                        <span class="badge bg-primary rounded-pill">{{ user.gestures|length }} gestures</span>
                    </div>
                    {% endfor %}
                </div>
                {% else %}
                <div class="alert alert-info">
                    <i class="fas fa-info-circle me-2"></i>No users registered yet.
                    <a href="/register" class="alert-link">Register a new user</a>
                </div>
                {% endif %}
            </div>
        </div>
    </div>

    <!-- Gesture List -->
    <div class="col-lg-4 mb-4">
        <div class="card shadow-sm h-100">
            <div class="card-header bg-primary text-white">
                <h4 class="mb-0"><i class="fas fa-hand-paper me-2"></i>Registered Gestures</h4>
            </div>
            <div class="card-body">
                {% if gestures %}
                <div class="table-responsive" style="max-height: 300px; overflow-y: auto;">
                    <table class="table table-hover table-sm">
                        <thead class="table-dark sticky-top" style="position: sticky; top: 0; z-index: 1;">
                            <tr>
                                <th>Gesture</th>
                                <th>Binding</th>
                                <th class="text-end">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for label, binding in gestures %}
                            <tr data-gesture-label="{{ label }}" data-gesture-binding="{{ binding }}">
                                <td>
                                    {% if 'left' in label %}
                                    <i class="fas fa-hand-point-left me-2 text-primary"></i>
                                    {% elif 'right' in label %}
                                    <i class="fas fa-hand-point-right me-2 text-primary"></i>
                                    {% elif 'up' in label %}
                                    <i class="fas fa-hand-point-up me-2 text-primary"></i>
                                    {% elif 'down' in label %}
                                    <i class="fas fa-hand-point-down me-2 text-primary"></i>
                                    {% else %}
                                    <i class="fas fa-hand-paper me-2 text-primary"></i>
                                    {% endif %}
                                    {{ label }}
                                </td>
                                <td><code>{{ binding }}</code></td>
                                <td class="text-end">
                                    <button type="button" class="btn btn-sm btn-outline-danger delete-gesture-btn"
                                            data-label="{{ label }}" data-binding="{{ binding }}">
                                        <i class="fas fa-trash-alt"></i>
                                    </button>
                                </td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
                {% else %}
                <div class="alert alert-info">
                    <i class="fas fa-info-circle me-2"></i>No gestures registered yet.
                    <button type="button" class="alert-link btn btn-link p-0" data-bs-toggle="modal" data-bs-target="#addGestureModal">Add a gesture</button>
                </div>
                {% endif %}
            </div>
        </div>
    </div>

    <!-- Training Sessions -->
    <div class="col-lg-4 mb-4">
        <div class="card shadow-sm h-100">
            <div class="card-header bg-primary text-white">
                <h4 class="mb-0"><i class="fas fa-brain me-2"></i>Training Sessions</h4>
            </div>
            <div class="card-body">
                {% if training_sessions %}
                <div class="list-group">
                    {% for session in training_sessions %}
                    <div class="list-group-item">
                        <div class="d-flex w-100 justify-content-between">
                            <h5 class="mb-1">Session #{{ session.id }}</h5>
                            {% if session.status == 'completed' %}
                            <span class="badge bg-success">Completed</span>
                            {% elif session.status == 'in_progress' %}
                            <span class="badge bg-warning">In Progress</span>
                            {% else %}
                            <span class="badge bg-danger">Failed</span>
                            {% endif %}
                        </div>
                        <p class="mb-1">
                            <strong>Started:</strong> {{ session.start_time.strftime('%Y-%m-%d %H:%M') }}<br>
                            {% if session.end_time %}
                            <strong>Completed:</strong> {{ session.end_time.strftime('%Y-%m-%d %H:%M') }}<br>
                            {% endif %}
                            {% if session.accuracy %}
                            <strong>Accuracy:</strong> {{ "%.2f"|format(session.accuracy * 100) }}%<br>
                            {% endif %}
                            {% if session.num_samples %}
                            <strong>Samples:</strong> {{ session.num_samples }}
                            {% endif %}
                        </p>
                        {% if session.error_message %}
                        <small class="text-danger">Error: {{ session.error_message }}</small>
                        {% endif %}
                    </div>
                    {% endfor %}
                </div>
                {% else %}
                <div class="alert alert-info">
                    <i class="fas fa-info-circle me-2"></i>No training sessions recorded yet.
                    <button type="button" class="alert-link btn btn-link p-0" onclick="triggerTraining()">Train the model</button>
                </div>
                {% endif %}
            </div>
        </div>
    </div>
</div>

<div class="row">
    <div class="col-lg-12">
        <div class="card shadow-sm">
            <div class="card-header bg-primary text-white">
                <h4 class="mb-0"><i class="fas fa-hand-sparkles me-2"></i>Gesture Recognition Demo</h4>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6">
                        <div class="webcam-container">
                            <video id="webcam" autoplay playsinline></video>
                            <div class="canvas-container">
                                <canvas id="overlay"></canvas>
                            </div>
                        </div>
                        <div class="d-grid gap-2 mt-3">
                            <button id="startWebcam" class="btn btn-primary">
                                <i class="fas fa-camera me-2"></i>Start Webcam
                            </button>
                            <button id="stopWebcam" class="btn btn-secondary d-none">
                                <i class="fas fa-stop me-2"></i>Stop Webcam
                            </button>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="card bg-dark mb-3">
                            <div class="card-header bg-primary text-white">
                                <h5 class="mb-0">Detection Results</h5>
                            </div>
                            <div class="card-body">
                                <div id="gestureResult" class="text-center py-4">
                                    <div class="display-1 mb-3">
                                        <i class="fas fa-hand-paper text-primary"></i>
                                    </div>
                                    <h3 id="detectedGesture">No gesture detected</h3>
                                    <p id="gestureConfidence" class="mb-0 text-muted">Waiting for input...</p>
                                </div>
                                <div class="alert alert-info mt-3">
                                    <i class="fas fa-info-circle me-2"></i>
                                    <strong>How to use:</strong> Position your hand in front of the camera and perform one of the registered gestures.
                                </div>
                            </div>
                        </div>
                        <div class="card">
                            <div class="card-header bg-primary text-white">
                                <h5 class="mb-0">Latest Events</h5>
                            </div>
                            <div class="card-body p-0">
                                <ul class="list-group list-group-flush" id="eventsLog">
                                    <li class="list-group-item">
                                        <small class="text-muted">System ready. Start webcam to begin detection.</small>
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Add Gesture Modal -->
<div class="modal fade" id="addGestureModal" tabindex="-1" aria-labelledby="addGestureModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header bg-primary text-white">
                <h5 class="modal-title" id="addGestureModalLabel">
                    <i class="fas fa-plus-circle me-2"></i>Add New Gesture
                </h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="row">
                    <div class="col-md-6">
                        <form id="addGestureForm">
                            <div class="mb-3">
                                <label for="user_id" class="form-label">User</label>
                                <select class="form-select" id="user_id" name="user_id" required>
                                    <option value="" disabled selected>Select user</option>
                                    {% for user in users %}
                                    <option value="{{ user.id }}">{{ user.username }}</option>
                                    {% endfor %}
                                </select>
                            </div>
                            <div class="mb-3">
                                <label for="gesture_name" class="form-label">Gesture Name</label>
                                <input type="text" class="form-control" id="gesture_name" name="gesture_name" required
                                       placeholder="e.g., swipe_left, hand_up">
                            </div>
                            <div class="mb-3">
                                <label for="gesture_binding" class="form-label">Binding (Action)</label>
                                <div class="input-group">
                                    <select class="form-select" id="predefined_bindings" onchange="updateBindingInput(this.value)">
                                        <option value="" selected>Select a predefined binding...</option>
                                        <optgroup label="Keyboard Keys">
                                            <option value="key_left">Left Arrow</option>
                                            <option value="key_right">Right Arrow</option>
                                            <option value="key_up">Up Arrow</option>
                                            <option value="key_down">Down Arrow</option>
                                            <option value="key_space">Space</option>
                                            <option value="key_enter">Enter</option>
                                            <option value="key_tab">Tab</option>
                                            <option value="key_esc">Escape</option>
                                            <option value="key_backspace">Backspace</option>
                                        </optgroup>
                                        <optgroup label="Media Controls">
                                            <option value="media_play_pause">Play/Pause Media</option>
                                            <option value="media_next">Next Track</option>
                                            <option value="media_prev">Previous Track</option>
                                            <option value="media_volume_up">Volume Up</option>
                                            <option value="media_volume_down">Volume Down</option>
                                            <option value="media_mute">Mute Volume</option>
                                        </optgroup>
                                        <optgroup label="OS Actions">
                                            <option value="os_window_maximize">Maximize Window</option>
                                            <option value="os_window_minimize">Minimize Window</option>
                                            <option value="os_window_close">Close Window</option>
                                            <option value="os_screenshot">Take Screenshot</option>
                                            <option value="os_lock_screen">Lock Screen</option>
                                        </optgroup>
                                        <optgroup label="App Actions">
                                            <option value="app_copy">Copy (Ctrl+C)</option>
                                            <option value="app_paste">Paste (Ctrl+V)</option>
                                            <option value="app_cut">Cut (Ctrl+X)</option>
                                            <option value="app_save">Save (Ctrl+S)</option>
                                            <option value="app_undo">Undo (Ctrl+Z)</option>
                                            <option value="app_redo">Redo (Ctrl+Y)</option>
                                        </optgroup>
                                        <optgroup label="Browser Actions">
                                            <option value="browser_back">Browser Back</option>
                                            <option value="browser_forward">Browser Forward</option>
                                            <option value="browser_refresh">Browser Refresh</option>
                                            <option value="browser_new_tab">New Tab</option>
                                            <option value="browser_close_tab">Close Tab</option>
                                        </optgroup>
                                        <option value="custom">Custom Binding...</option>
                                    </select>
                                    <input type="text" class="form-control" id="gesture_binding" name="gesture_binding" required
                                           placeholder="e.g., previous_page, scroll_up">
                                </div>
                                <small class="form-text text-muted">Select a predefined binding or enter a custom one</small>
                            </div>
                            <div class="alert alert-info">
                                <i class="fas fa-info-circle me-2"></i>
                                Position your hand in front of the camera. Click "Capture Gesture" when ready.
                            </div>
                            <div class="d-grid">
                                <button type="button" id="captureGesture" class="btn btn-primary" disabled>
                                    <i class="fas fa-camera me-2"></i>Capture Gesture
                                </button>
                            </div>
                        </form>
                    </div>
                    <div class="col-md-6">
                        <div class="webcam-container mb-3">
                            <video id="gestureWebcam" autoplay playsinline></video>
                            <div class="canvas-container">
                                <canvas id="gestureOverlay"></canvas>
                            </div>
                        </div>
                        <div id="capturedKeypoints" class="mb-3 d-none">
                            <div class="alert alert-success">
                                <i class="fas fa-check-circle me-2"></i>
                                <strong>Gesture captured!</strong> Click "Save Gesture" to add it to the system.
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" id="saveGesture" class="btn btn-primary" disabled>
                    <i class="fas fa-save me-2"></i>Save Gesture
                </button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic@0.5.1635989137/holistic.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Main webcam for gesture recognition
    const webcam = document.getElementById('webcam');
    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('startWebcam');
    const stopBtn = document.getElementById('stopWebcam');
    const detectedGesture = document.getElementById('detectedGesture');
    const gestureConfidence = document.getElementById('gestureConfidence');
    const eventsLog = document.getElementById('eventsLog');
    
    // Gesture capture webcam
    const gestureWebcam = document.getElementById('gestureWebcam');
    const gestureOverlay = document.getElementById('gestureOverlay');
    const captureGestureBtn = document.getElementById('captureGesture');
    const saveGestureBtn = document.getElementById('saveGesture');
    const capturedKeypoints = document.getElementById('capturedKeypoints');
    
    let mainStream = null;
    let gestureStream = null;
    let holistic = null;
    let isModelReady = false;
    let capturedHandKeypoints = null;
    
    // Initialize MediaPipe Holistic model
    function initHolisticModel() {
        holistic = new Holistic({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/holistic@0.5.1635989137/${file}`;
            }
        });
        
        holistic.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            enableSegmentation: false,
            smoothSegmentation: false,
            refineFaceLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        holistic.onResults(onHolisticResults);
        
        // Only enable the capture button when holistic model is ready
        holistic.initialize().then(() => {
            isModelReady = true;
            captureGestureBtn.disabled = false;
            addEvent('Holistic tracking model loaded successfully');
        });
    }
    
    // Handle results from MediaPipe Holistic
    function onHolisticResults(results) {
        const ctx = overlay.getContext('2d');
        ctx.clearRect(0, 0, overlay.width, overlay.height);
        
        // Draw face landmarks if available
        if (results.faceLandmarks) {
            drawFaceLandmarks(ctx, results.faceLandmarks);
        }
        
        // Draw pose landmarks if available
        if (results.poseLandmarks) {
            drawPoseLandmarks(ctx, results.poseLandmarks);
        }
        
        // Process hand landmarks if available
        if (results.rightHandLandmarks) {
            drawHandLandmarks(ctx, results.rightHandLandmarks, 'right');
            
            // Extract keypoints and recognize gesture
            const keypoints = extractKeypoints(results.rightHandLandmarks);
            recognizeGesture(keypoints);
        } else if (results.leftHandLandmarks) {
            drawHandLandmarks(ctx, results.leftHandLandmarks, 'left');
            
            // Extract keypoints and recognize gesture
            const keypoints = extractKeypoints(results.leftHandLandmarks);
            recognizeGesture(keypoints);
        } else {
            detectedGesture.textContent = 'No hand detected';
            gestureConfidence.textContent = 'Waiting for input...';
        }
    }
    
    // Extract keypoints from MediaPipe landmarks
    function extractKeypoints(landmarks) {
        // Create flat array of keypoints
        const keypoints = [];
        for (const landmark of landmarks) {
            keypoints.push(landmark.x, landmark.y, landmark.z);
        }
        return keypoints;
    }
    
    // Draw face landmarks on canvas
    function drawFaceLandmarks(ctx, landmarks) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        
        // Draw a subset of face landmarks for simplicity
        for (let i = 0; i < landmarks.length; i += 5) {
            const landmark = landmarks[i];
            ctx.beginPath();
            ctx.arc(
                landmark.x * overlay.width,
                landmark.y * overlay.height,
                2,
                0,
                2 * Math.PI
            );
            ctx.fill();
        }
    }
    
    // Draw pose landmarks on canvas
    function drawPoseLandmarks(ctx, landmarks) {
        // Draw pose connections
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgba(100, 200, 255, 0.7)';
        
        // Draw main body connections
        const connections = [
            [11, 12], // shoulders
            [11, 13], [13, 15], // left arm
            [12, 14], [14, 16], // right arm
            [11, 23], [12, 24], // body to hips
            [23, 24], // hips
        ];
        
        for (const connection of connections) {
            const [i, j] = connection;
            if (landmarks[i].visibility > 0.5 && landmarks[j].visibility > 0.5) {
                ctx.beginPath();
                ctx.moveTo(landmarks[i].x * overlay.width, landmarks[i].y * overlay.height);
                ctx.lineTo(landmarks[j].x * overlay.width, landmarks[j].y * overlay.height);
                ctx.stroke();
            }
        }
        
        // Draw pose landmarks
        ctx.fillStyle = '#4080FF';
        for (let i = 0; i < landmarks.length; i++) {
            // Focus on upper body landmarks (11-16 are shoulders and arms)
            if (i >= 11 && i <= 16 && landmarks[i].visibility > 0.5) {
                ctx.beginPath();
                ctx.arc(
                    landmarks[i].x * overlay.width,
                    landmarks[i].y * overlay.height,
                    5,
                    0,
                    2 * Math.PI
                );
                ctx.fill();
            }
        }
    }
    
    // Draw hand landmarks on canvas
    function drawHandLandmarks(ctx, landmarks, handType) {
        // Draw connections
        ctx.lineWidth = 3;
        ctx.strokeStyle = handType === 'left' ? '#FF8000' : '#00FF80';
        
        // Draw hand connections (simplified)
        const connections = [
            [0, 1], [1, 2], [2, 3], [3, 4],           // thumb
            [0, 5], [5, 6], [6, 7], [7, 8],           // index finger
            [0, 9], [9, 10], [10, 11], [11, 12],      // middle finger
            [0, 13], [13, 14], [14, 15], [15, 16],    // ring finger
            [0, 17], [17, 18], [18, 19], [19, 20],    // pinky
            [0, 5], [5, 9], [9, 13], [13, 17],        // palm
        ];
        
        for (const connection of connections) {
            const [i, j] = connection;
            ctx.beginPath();
            ctx.moveTo(landmarks[i].x * overlay.width, landmarks[i].y * overlay.height);
            ctx.lineTo(landmarks[j].x * overlay.width, landmarks[j].y * overlay.height);
            ctx.stroke();
        }
        
        // Draw landmarks
        ctx.fillStyle = handType === 'left' ? '#FFA040' : '#40FFA0';
        for (const landmark of landmarks) {
            ctx.beginPath();
            ctx.arc(
                landmark.x * overlay.width,
                landmark.y * overlay.height,
                5,
                0,
                2 * Math.PI
            );
            ctx.fill();
        }
        
        // Add hand type label
        ctx.font = '16px Arial';
        ctx.fillStyle = handType === 'left' ? '#FFA040' : '#40FFA0';
        ctx.fillText(
            `${handType.toUpperCase()} HAND`, 
            landmarks[0].x * overlay.width - 40, 
            landmarks[0].y * overlay.height - 20
        );
    }
    
    // Recognize gesture using keypoints
    function recognizeGesture(keypoints) {
        // Call the API to recognize the gesture
        fetch('/api/gestures/recognize', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ keypoints })
        })
        .then(response => response.json())
        .then(data => {
            if (data.gesture) {
                // Update UI with detected gesture
                detectedGesture.textContent = data.gesture;
                gestureConfidence.textContent = `Confidence: ${(data.confidence * 100).toFixed(1)}%`;
                
                // Check if confidence is high enough
                if (data.confidence >= 0.7) {
                    addEvent(`Detected gesture: ${data.gesture} (${(data.confidence * 100).toFixed(1)}%)`);
                    
                    // Map gesture names to icons
                    let iconClass = 'fa-hand-paper';
                    if (data.gesture.includes('left')) iconClass = 'fa-hand-point-left';
                    if (data.gesture.includes('right')) iconClass = 'fa-hand-point-right';
                    if (data.gesture.includes('up')) iconClass = 'fa-hand-point-up';
                    if (data.gesture.includes('down')) iconClass = 'fa-hand-point-down';
                    
                    // Update icon
                    const iconElement = document.querySelector('#gestureResult .fas');
                    iconElement.className = `fas ${iconClass} text-primary`;
                }
            }
        })
        .catch(error => {
            console.error('Error recognizing gesture:', error);
        });
    }
    
    // Start webcam for main gesture recognition
    startBtn.addEventListener('click', async function() {
        try {
            mainStream = await navigator.mediaDevices.getUserMedia({ video: true });
            webcam.srcObject = mainStream;
            webcam.play();
            
            // Wait for video to be ready
            webcam.addEventListener('loadedmetadata', () => {
                // Set canvas dimensions
                overlay.width = webcam.videoWidth;
                overlay.height = webcam.videoHeight;
                
                // Initialize holistic tracking if not already
                if (!isModelReady) {
                    initHolisticModel();
                }
                
                // Start processing frames
                processFrames();
            });
            
            startBtn.classList.add('d-none');
            stopBtn.classList.remove('d-none');
            addEvent('Webcam started');
        } catch (err) {
            console.error('Error accessing webcam:', err);
            addEvent('Error accessing webcam: ' + err.message);
            alert('Could not access webcam. Please check permissions.');
        }
    });
    
    // Stop webcam
    stopBtn.addEventListener('click', function() {
        if (mainStream) {
            mainStream.getTracks().forEach(track => track.stop());
            mainStream = null;
        }
        
        startBtn.classList.remove('d-none');
        stopBtn.classList.add('d-none');
        addEvent('Webcam stopped');
    });
    
    // Process video frames for holistic tracking
    function processFrames() {
        if (!mainStream) return;
        
        if (holistic && webcam.readyState === 4) {
            holistic.send({ image: webcam });
        }
        
        requestAnimationFrame(processFrames);
    }
    
    // Add event to the log
    function addEvent(message) {
        const li = document.createElement('li');
        li.className = 'list-group-item';
        
        const time = new Date().toLocaleTimeString();
        li.innerHTML = `<small class="text-muted">${time}</small> ${message}`;
        
        eventsLog.insertBefore(li, eventsLog.firstChild);
        
        // Limit log to 10 entries
        if (eventsLog.children.length > 10) {
            eventsLog.removeChild(eventsLog.lastChild);
        }
    }
    
    // Modal for adding new gestures
    const addGestureModal = document.getElementById('addGestureModal');
    
    // Start gesture webcam when modal opens
    addGestureModal.addEventListener('shown.bs.modal', async function() {
        try {
            gestureStream = await navigator.mediaDevices.getUserMedia({ video: true });
            gestureWebcam.srcObject = gestureStream;
            
            // Set up canvas
            gestureWebcam.addEventListener('loadedmetadata', () => {
                gestureOverlay.width = gestureWebcam.videoWidth;
                gestureOverlay.height = gestureWebcam.videoHeight;
                
                // Initialize holistic model if not already
                if (!isModelReady) {
                    initHolisticModel();
                }
            });
        } catch (err) {
            console.error('Error accessing webcam for gesture capture:', err);
            alert('Could not access webcam for gesture capture. Please check permissions.');
        }
    });
    
    // Stop gesture webcam when modal closes
    addGestureModal.addEventListener('hidden.bs.modal', function() {
        if (gestureStream) {
            gestureStream.getTracks().forEach(track => track.stop());
            gestureStream = null;
        }
        
        // Reset the form
        document.getElementById('addGestureForm').reset();
        capturedHandKeypoints = null;
        
        // Fix: check if capturedKeypoints element exists before accessing it
        if (capturedKeypoints) {
            capturedKeypoints.classList.add('d-none');
        }
        
        saveGestureBtn.disabled = true;
    });
    
    // Capture gesture
    captureGestureBtn.addEventListener('click', function() {
        // Render current frame to canvas
        const canvas = document.createElement('canvas');
        canvas.width = gestureWebcam.videoWidth;
        canvas.height = gestureWebcam.videoHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(gestureWebcam, 0, 0, canvas.width, canvas.height);
        
        // Process image with MediaPipe Holistic
        holistic.send({ image: gestureWebcam }).then(() => {
            // Check for hand landmarks (prioritize right hand, then left hand)
            let handLandmarks = null;
            let handType = '';
            
            if (holistic.results.rightHandLandmarks) {
                handLandmarks = holistic.results.rightHandLandmarks;
                handType = 'right';
            } else if (holistic.results.leftHandLandmarks) {
                handLandmarks = holistic.results.leftHandLandmarks;
                handType = 'left';
            }
            
            if (handLandmarks) {
                // Extract keypoints
                capturedHandKeypoints = extractKeypoints(handLandmarks);
                
                // Clear canvas and draw landmarks
                const overlayCtx = gestureOverlay.getContext('2d');
                overlayCtx.clearRect(0, 0, gestureOverlay.width, gestureOverlay.height);
                
                // Draw face and pose for context
                if (holistic.results.faceLandmarks) {
                    drawFaceLandmarks(overlayCtx, holistic.results.faceLandmarks);
                }
                if (holistic.results.poseLandmarks) {
                    drawPoseLandmarks(overlayCtx, holistic.results.poseLandmarks);
                }
                
                // Draw hand landmarks
                drawHandLandmarks(overlayCtx, handLandmarks, handType);
                
                // Show success message
                capturedKeypoints.classList.remove('d-none');
                saveGestureBtn.disabled = false;
                
                addEvent(`Captured ${handType} hand gesture`);
            } else {
                alert('No hand detected. Please position your hand in front of the camera.');
            }
        });
    });
    
    // Save gesture
    saveGestureBtn.addEventListener('click', function() {
        const userId = document.getElementById('user_id').value;
        const gestureName = document.getElementById('gesture_name').value;
        const gestureBinding = document.getElementById('gesture_binding').value;
        
        if (!userId || !gestureName || !gestureBinding || !capturedHandKeypoints) {
            alert('Please fill all fields and capture a gesture');
            return;
        }
        
        // Send data to API
        fetch('/api/gestures/add', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                user_id: parseInt(userId),
                label: gestureName,
                binding: gestureBinding,
                keypoints: capturedHandKeypoints
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                alert('Gesture added successfully!');
                
                // Close modal
                const modal = bootstrap.Modal.getInstance(addGestureModal);
                modal.hide();
                
                // Reload page to update UI
                window.location.reload();
            } else {
                alert('Error adding gesture: ' + data.message);
            }
        })
        .catch(error => {
            console.error('Error adding gesture:', error);
            alert('Error adding gesture. See console for details.');
        });
    });
    
    // Setup delete gesture buttons
    document.querySelectorAll('.delete-gesture-btn').forEach(button => {
        button.addEventListener('click', function() {
            const label = this.getAttribute('data-label');
            const binding = this.getAttribute('data-binding');
            deleteGesture(label, binding);
        });
    });
    
    // Function to update the binding input when a predefined binding is selected
    function updateBindingInput(value) {
        const bindingInput = document.getElementById('gesture_binding');
        if (value && value !== 'custom') {
            bindingInput.value = value;
            bindingInput.readOnly = true;
        } else {
            bindingInput.value = '';
            bindingInput.readOnly = false;
            bindingInput.focus();
        }
    }
    
    // Function to delete a gesture
    function deleteGesture(label, binding) {
        if (confirm(`Are you sure you want to delete the gesture "${label}" with binding "${binding}"?`)) {
            // Send delete request to API
            fetch('/api/gestures/delete', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    label: label,
                    binding: binding
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    addEvent(`Deleted gesture "${label}" with binding "${binding}"`);
                    // Reload page to reflect changes
                    window.location.reload();
                } else {
                    alert(`Failed to delete gesture: ${data.message}`);
                }
            })
            .catch(error => {
                console.error('Error deleting gesture:', error);
                alert('Error deleting gesture. Please try again.');
            });
        }
    }
});

// Trigger model training
function triggerTraining() {
    fetch('/api/train', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert('Model training started successfully!');
            window.location.reload();
        } else {
            alert('Error starting model training: ' + data.message);
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error starting model training. See console for details.');
    });
}
</script>
{% endblock %}